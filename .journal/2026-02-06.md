## AppKit Host Demo — React-Native-Style Imperative Rendering

- Core Decision/Topic: Build a second macOS host example using pure AppKit with a view model layer and diff-based reconciliation, mirroring how Raycast and React Native render React component trees into native platform views.

- Options Considered:
  1. Enhance the existing SwiftUI demo with better diffing — rejected because SwiftUI's declarative model fights against manual diffing; `body` rebuilds everything on state change regardless.
  2. Use SwiftUI with `UIViewRepresentable`-style wrapping of AppKit views — hybrid approach adds complexity without the full benefits.
  3. Pure AppKit with an intermediate ViewModel layer and tree reconciler — chosen because it demonstrates the React Native architecture pattern cleanly: JSON tree → ViewModel → imperative native view mutations.

- Final Decision & Rationale: Pure AppKit with `NodeViewModel` (reference type, dirty-tracking bitfield) and `TreeReconciler` (id-based O(1) matching, three-phase reconciliation). This is the same architecture React Native uses (shadow tree → native view commands) and what Raycast uses for their React extensions. The key insight: imperative frameworks give you direct control over *when* and *what* to update, which is exactly what a host-side reconciler needs.

- Key Changes Made:
  - **17 Swift source files** in `examples/host-appkit-demo/`
  - **App layer**: `main.swift` + `AppDelegate` (no SwiftUI `@main`), `MainWindowController`, `MainViewController` with connection chrome + plugin content area
  - **Models**: Copied verbatim from SwiftUI demo (`UINode`, `RPCMessage`, `MessageParser`)
  - **Services**: `WebSocketClient` (verbatim), `RPCClient` (kept `@MainActor` — removing it caused data races on `pendingRequests` between send and receive paths)
  - **ViewModels**: `NodeViewModel` with `DirtyFields` OptionSet bitfield, `TreeReconciler` with id-based matching and three-phase children reconciliation (match/update, remove, reorder)
  - **Views**: `ContainerView` (NSStackView), `TextNodeView` (NSTextField label), `ButtonNodeView` (NSButton target/action), `InputNodeView` (NSTextField + delegate), `ListContainerView`/`ListItemView` — all conforming to `UpdatableNodeView` protocol
  - **Xcode project**: Full `.xcodeproj` with proper build phases, macOS 14.0 deployment target

- Critical Bug Found & Fixed:
  - **NSScrollView hit testing failure**: The plugin content renders inside an NSScrollView. The document view (FlippedView) had no bottom Auto Layout constraint from its content, so its height was 0. NSView renders outside its bounds by default (so UI appeared correct), but NSClipView clips hit testing to the document view's frame. Result: all clicks and keyboard events were silently dropped. Fix: add `view.bottomAnchor.constraint(equalTo: pluginContentView.bottomAnchor)` to define the document view's height from its content.
  - **`@MainActor` is required on RPCClient**: The initial attempt removed `@MainActor` (to avoid SwiftUI dependency). This caused silent data races — `pendingRequests` was accessed from the cooperative thread pool (inside `sendRequest`'s inner `Task`) and the main thread (inside `handleResponse` via WebSocket callback). Responses matched to empty pending maps, so handlers never resolved. Fix: keep `@MainActor`, use `Task { @MainActor in }` for WebSocket callbacks.

- Future Considerations:
  - Add more component types (select, checkbox, textarea, image)
  - Implement animation support for prop transitions
  - Add accessibility (NSAccessibility protocol conformance)
  - Consider extracting the reconciler as a reusable framework for any AppKit host
