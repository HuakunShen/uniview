# 2026-02-09

## 1. Solid Plugin Node.js Runtime + Host Framework Selector

**Timestamp:** 2026-02-09
**Topic:** Adding Node.js (WebSocket) runtime support for Solid plugins and framework selector UI

### Options Considered

- **Run .client.ts source directly with Bun** (like React plugins do) — rejected because Bun can't natively run Solid's universal JSX transform; the Babel + `babel-preset-solid` + `generate: "universal"` pipeline must run first.
- **Build client entries with `target: "bun"`** — chosen; Bun.build handles the Babel transform via plugin, then the built JS is executed by Bun at runtime.

### Final Decision & Rationale

Client entries (`simple-demo.client.ts`, `advanced-demo.client.ts`) are built alongside worker entries in `build.ts`, using `target: "bun"` with the same `solidTransformPlugin`. The `dev:all:solid` orchestration script builds first, then starts bridge + clients + Svelte host in parallel.

### Key Changes Made

- **Created** `examples/plugin-solid-example/src/simple-demo.client.ts` and `advanced-demo.client.ts` — WebSocket client entries using `createSolidWebSocketPluginClient()` with `solid-` prefixed plugin IDs.
- **Modified** `examples/plugin-solid-example/build.ts` — added `clientEntrypoints` array built with `target: "bun"`.
- **Modified** `examples/plugin-solid-example/package.json` — added `client`, `client:simple`, `client:advanced` scripts.
- **Modified** `examples/bridge-server/src/index.ts` — added `GET /solid/:filename` route serving from `plugin-solid-example/dist/`.
- **Modified** `examples/host-svelte-demo/package.json` — added `dev:all:solid` and `solid-plugins:wait` (with build step before client launch).
- **Modified** `examples/host-svelte-demo/src/routes/+page.svelte` — added React/Solid framework selector, conditional worker URLs (`/solid/` prefix), plugin IDs (`solid-` prefix), disabled main-thread for Solid.

### Future Considerations

- The `solid-plugins:wait` script runs a full build before launching clients. This adds startup latency vs React's `dev:all` which assumes pre-built plugins. A watch-mode alternative could improve DX.

---

## 2. Fix: Solid Plugin Node.js Mode Reactivity Bug

**Timestamp:** 2026-02-09
**Topic:** Solid plugins completely non-reactive in Node.js (WebSocket) mode — buttons, inputs, toggles all non-functional

### Root Cause

`Bun.build({ target: "bun" })` resolves `solid-js` using the `"node"` export condition, which maps to `solid-js/dist/server.js` — the SSR stub. In this version:

- `createSignal` returns a plain closure (no reactive tracking)
- `createRenderEffect` (aliased to `createComputed`) runs once synchronously, never re-executes on signal changes

The worker build uses `target: "browser"` which resolves to `solid-js/dist/dev.js` with full reactivity.

**Evidence:**

- Client bundle comment: `solid-js@1.9.11/.../dist/server.js`
- Worker bundle comment: `solid-js@1.9.11/.../dist/dev.js`

### Options Considered

1. **Switch client target to `"browser"`** — rejected; would add unnecessary browser polyfills (Buffer, etc.) and break Bun-native APIs used by kkrpc WebSocket transport.
2. **Mark `solid-js` as external** — rejected; at runtime Bun would still resolve to server.js via the `"node"` condition.
3. **Add `conditions: ["browser"]` to client build** — chosen; tells Bun's resolver to prefer the `"browser"` export condition, getting the reactive version while keeping `target: "bun"` for everything else.

### Final Decision & Rationale

One-line fix: add `conditions: ["browser"]` to the `Bun.build()` config for client entrypoints. This is the minimal, targeted fix — it overrides only the export condition resolution without changing the target environment or bundling strategy.

### Key Changes Made

- **Modified** `examples/plugin-solid-example/build.ts` — added `conditions: ["browser"]` to client build config.

### Future Considerations

- Any future runtime package targeting Bun/Node that depends on `solid-js` will need the same `conditions: ["browser"]` override. This is a fundamental constraint of Solid's package exports: the `"node"` condition maps to the non-reactive SSR build.
- Consider documenting this in CLAUDE.md as an anti-pattern: "NEVER build Solid client entries with `target: 'bun'` without `conditions: ['browser']`."

---

## 3. Incremental Update Protocol Implementation

**Timestamp:** 2026-02-09
**Topic:** Implemented mutation-based incremental updates to replace full tree serialization

### Problem

Both React and Solid renderers were serializing and sending the entire UI tree on every update. For a 500-item list with one changed item, this meant ~200KB JSON payload instead of ~50 bytes for the actual change.

### Options Considered

1. **Virtual DOM diffing on host** — rejected; still requires full tree serialization from plugin
2. **Mutation commands like React Native** — chosen; reconciler/universal renderer already knows exactly what changed
3. **CRDT-based sync** — rejected; overkill for this use case, adds complexity

### Final Decision & Rationale

Implemented incremental mutation protocol:

- First render: full tree via `updateTree()`
- Subsequent updates: `applyMutations(mutations[])` with specific operations
- Protocol version bumped to 2 (breaking change)

**Key insight:** React's reconciler HostConfig and Solid's universal renderer already emit fine-grained updates. We just needed to capture them instead of re-serializing the entire tree.

### Key Changes Made

- **Created** `packages/protocol/src/mutations.ts` — 6 mutation types: create, remove, setProp, removeProp, setText, reorder
- **Modified** `packages/protocol/src/rpc.ts` — added `applyMutations()` to `PluginToHostAPI`
- **Modified** `packages/protocol/src/version.ts` — bumped `PROTOCOL_VERSION` to 2
- **Created** `packages/host-sdk/src/mutable-tree.ts` — `MutableTree` class for host-side mutation application
- **Modified** all host controllers (worker, websocket, main) — use `MutableTree`, expose `TreeUpdate` type
- **Created** `packages/react-renderer/src/serialization/mutation-collector.ts` — collects mutations from HostConfig callbacks
- **Modified** `packages/react-renderer/src/reconciler/host-config.ts` — emit mutations instead of full tree
- **Created** `packages/solid-renderer/src/serialization/mutation-collector.ts` — collects mutations from universal renderer
- **Modified** `packages/solid-renderer/src/renderer/reconciler.ts` — emit mutations for setProperty/insertNode/removeNode/replaceText
- **Modified** both runtime packages — use mutation mode after first render
- **Modified** `packages/host-svelte/src/PluginHost.svelte` — handle `TreeUpdate` union type, apply mutations to tree

### Future Considerations

- React renderer still needs proper `MutationCollector` integration for all HostConfig callbacks (currently partial)
- Text node handling differs between React (plain strings) and Solid (UINode objects) — may need unification
- Protocol v2 is breaking; old plugins will fail to connect to new hosts (clear error message on version mismatch)

---

## 4. Fix: React Worker Mode Silent Rendering Failure

**Timestamp:** 2026-02-09
**Topic:** React plugins fail to render in Web Worker mode (Solid works, React Node.js mode works)

### Root Cause

Two interacting bugs introduced during the incremental update protocol (entry #3):

**Bug 1 — React runtime sends mutations on first render, missing the root node.**
The React reconciler's `appendChildToContainer()` assigns the root node to `container.rootInstance` but does NOT emit a mutation for it. All child-to-parent `appendInitialChild()` calls emit `create` mutations referencing their parent IDs, but the root node (`parentId: null`) is never in the batch. Result: 11 mutations arrive, all referencing parents that can't be found because the root was never created.

The Solid runtime avoided this by explicitly sending a full tree (`updateTree()`) on first render (checking `isFirstRender` flag), only using mutations for subsequent updates. The React runtime had no such guard — it always forwarded whatever the bridge emitted, which was mutations from the `MutationCollector`.

**Bug 2 — PluginHost early-returns on null tree.**
`PluginHost.svelte`'s `applyMutations()` had `if (!tree) return;` at the top. Even if a correct root-creation mutation with `parentId: null` had arrived, the function would bail before processing it because `tree` starts as `null`. This was a defensive guard that became a blocking bug.

### Why It Was Hard to Find

The failure was completely silent:

- Worker loaded successfully (200 OK, blob URL created)
- RPC channel established, `initialize()` called and completed
- React rendered, 11 mutations collected and sent
- No console errors anywhere — neither Worker nor host

The mutations simply disappeared into `applyMutations()` which returned early on `!tree`. Debugging required injecting logs into both the Worker (plugin side) and the built `host-svelte` package (host side) to trace the full data flow.

### Options Considered

1. **Emit root creation mutation from `appendChildToContainer()`** — adds `collectAppendToRoot()` to `MutationCollector` with `parentId: null`. Problem: mutations arrive bottom-up (children before parents), so the host would need to buffer and reorder, or use a node map instead of tree traversal. Adds complexity to both sides.

2. **Send full tree on first render, mutations thereafter** (like Solid does) — chosen. Minimal change, mirrors proven Solid pattern, sidesteps the fundamental issue that React's reconciler build phase doesn't emit a root creation event compatible with the mutation protocol.

### Final Decision & Rationale

Adopted option 2: on first render, the React runtime reads `bridge.rootInstance` directly (the fully-built `InternalNode` tree) and sends it via `updateTree()`. Subsequent renders use mutations as before. This matches the Solid runtime's `isFirstRender` pattern exactly.

Also removed the `if (!tree) return` guard from `PluginHost.applyMutations()` so future mutation-based first renders (if ever implemented) won't silently fail.

Added `worker.onerror` handler to `createWorkerController` for better error visibility in future Worker issues.

### Key Changes Made

- **Modified** `packages/runtime/src/runtime.ts` — check `isFirstRender` in bridge subscribe callback; on first render, serialize `bridge.rootInstance` as full tree via `updateTree()` instead of forwarding mutations. Clear handler registry before re-serializing to avoid stale handler IDs.
- **Modified** `packages/host-svelte/src/PluginHost.svelte` — removed `if (!tree) return` guard from `applyMutations()`.
- **Modified** `packages/host-sdk/src/controllers/worker.ts` — added `worker.onerror` handler for error visibility.

### Future Considerations

- The React reconciler's `appendChildToContainer` is a gap in mutation collection. If full-mutation-based first render is ever desired (to avoid double serialization), this needs to be addressed along with mutation ordering (root must come first, or host must use a node map).
- The `isFirstRender` pattern is now duplicated between React and Solid runtimes. Consider extracting to a shared utility if a third renderer is added.

---

## 5. Fix: Solid Text Node Rendering in Svelte Host

**Timestamp:** 2026-02-09
**Topic:** Text nodes from Solid plugins not rendering (transparent/empty space)

### Root Cause

Solid's universal renderer creates text nodes as UINode objects with `type: "text"` and stores the text in `props.text`. The Svelte host was:

1. Inserting text nodes as UINode objects (correct)
2. But `ComponentRenderer.svelte` had no case for `type: "text"`, falling through to "Unknown"
3. `applySetText` in PluginHost was trying to replace the child with a plain string (wrong approach)

### Options Considered

1. **Store text as plain strings in children array** — rejected; loses node ID needed for `setText` mutations
2. **Add text node case to ComponentRenderer** — chosen; maintains ID-based mutation updates

### Final Decision & Rationale

Text nodes must remain as UINode objects so `setText` mutations can target them by ID. Added explicit handling in ComponentRenderer to render `node.props.text` for `type: "text"` nodes.

### Key Changes Made

- **Modified** `packages/host-svelte/src/ComponentRenderer.svelte` — added `{:else if node.type === "text"}` case rendering `{node.props.text}`
- **Modified** `packages/host-svelte/src/PluginHost.svelte` — fixed `applySetText` to update `child.props.text` instead of replacing child

### Performance Impact

- Before: 500-item list text change = ~200KB full tree
- After: single text mutation = ~50 bytes
- Solid's fine-grained reactivity now fully utilized

---
