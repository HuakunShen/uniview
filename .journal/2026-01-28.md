# Journal - 2026-01-28

## 09:23 - Uniview Demo Debugging: Vue, React Host Fixes

### Core Issue

Multiple bugs in the Vue and React host demo applications preventing proper plugin interaction in Node.js/WebSocket mode.

### Problems Fixed

#### 1. Vue Demo: Switch & Toggle State Sync Issues

**Problem**: In `host-vue-demo`, Switch components could toggle the UI but state didn't sync back to the plugin. Toggle components allowed multiple selections instead of radio-button behavior (causing flickering/infinite loops).

**Root Cause**: reka-ui v2 changed from `v-model:checked`/`v-model:pressed` to unified `v-model` pattern. The old implementation used watchers that created feedback loops when prop changes triggered watchers which fired callbacks which updated props again.

**Solution**: Changed from local ref + watchers to computed + `@update:model-value` handler pattern:

```vue
<!-- Before (broken) -->
<script setup>
const checked = ref(props.checked);
watch(
  () => props.checked,
  (v) => (checked.value = v),
); // Feedback loop!
watch(checked, (v) => props.onChange?.(v));
</script>
<Switch v-model:checked="checked" />

<!-- After (fixed) -->
<script setup>
const checkedState = computed(() => props.checked ?? props.defaultChecked ?? false);
function handleCheckedChange(newChecked: boolean) {
  props.onChange?.(newChecked);
}
</script>
<Switch :model-value="checkedState" @update:model-value="handleCheckedChange" />
```

**Files**:

- `examples/host-vue-demo/src/lib/components/plugin/PluginSwitch.vue`
- `examples/host-vue-demo/src/lib/components/plugin/PluginToggle.vue`

#### 2. React Demo: Circular Reference Error on Button Click

**Problem**: Clicking buttons in `host-react-demo` threw "Converting circular structure to JSON" error.

**Root Cause**: `PluginButton.tsx` was passing the full `MouseEvent` object to the `onClick` callback. MouseEvent contains DOM elements with React Fiber internals that have circular references, which can't be serialized for RPC.

**Solution**: Don't pass the event object - plugins don't need it:

```typescript
// Before (broken)
const handleClick = (e: MouseEvent<HTMLButtonElement>) => {
  onClick?.(e); // Passing full event object - circular refs!
};

// After (fixed)
const handleClick = () => {
  onClick?.(); // No event - clean RPC
};
```

**File**: `examples/host-react-demo/src/lib/components/plugin/PluginButton.tsx`

#### 3. React Demo: Controller Lifecycle Bug in Node.js Mode

**Problem**: In Node.js/WebSocket mode, switching between demos caused the second plugin to not respond. Duplicate WebSocket connections appeared in console logs.

**Root Cause**: `useMemo` creates a new controller immediately when dependencies change, but the old controller isn't disconnected until PluginHost's useEffect cleanup runs. This causes:

- Two controllers connecting simultaneously
- Bridge server confusion with multiple host connections for same pluginId
- Race conditions in connection establishment

**Solution**: Changed from `useMemo` to `useEffect` + `useRef` pattern ensuring old controller disconnects BEFORE new one is created:

```typescript
// Before (broken)
const controller = useMemo(() => {
  return createWebSocketController({ serverUrl, pluginId });
}, [runtimeMode, currentDemo, ...]);  // New controller created before old cleanup

// After (fixed)
const controllerRef = useRef<PluginController | null>(null);
const [controller, setController] = useState<PluginController | null>(null);

useEffect(() => {
  controllerRef.current?.disconnect();  // Disconnect old FIRST

  let newController = createWebSocketController({ serverUrl, pluginId });
  controllerRef.current = newController;
  setController(newController);

  return () => {
    controllerRef.current?.disconnect();
    controllerRef.current = null;
  };
}, [runtimeMode, currentDemo, pluginUrl, pluginId, bridgeServerUrl]);
```

**File**: `examples/host-react-demo/src/App.tsx`

#### 4. Tailwind CSS Classes Not Generated

**Problem**: Tailwind classes like `justify-between` from plugin code weren't being applied in both Vue and React demos.

**Root Cause**: Tailwind's content scanning didn't include the plugin source files.

**Solution**: Added `@source` directive to include plugin directory:

```css
@source "../../plugin-example/src";
```

**Files**:

- `examples/host-vue-demo/src/styles.css`
- `examples/host-react-demo/src/index.css`

### Key Patterns Established

1. **Controlled Components over RPC**: Host components should be fully controlled by props from plugin. Use computed/derived state, not local state with watchers.

2. **No Event Objects over RPC**: Never pass DOM event objects through RPC - they contain circular references and framework internals.

3. **Controller Lifecycle in React**: When creating resources that need cleanup (WebSocket connections, Workers), use `useEffect` with cleanup, not `useMemo`. Ensure old resource is disposed BEFORE creating new one.

4. **Tailwind Cross-Package Scanning**: When plugins define classes, host apps must configure Tailwind to scan plugin source directories.

### Testing Notes

Verified with Playwright automation:

- Switch toggles on/off correctly, state syncs to plugin
- Toggle group has radio behavior (one pressed at a time)
- Button clicks work without errors
- Demo switching in Node.js mode works (though React StrictMode causes double effect runs in dev)
